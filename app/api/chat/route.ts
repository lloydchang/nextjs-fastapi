// File: app/api/chat/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { v4 as uuidv4 } from 'uuid';
import { getConfig, AppConfig } from 'app/api/chat/utils/config';
import { checkRateLimit } from 'app/api/chat/utils/rateLimiter';
import { extractValidMessages } from 'app/api/chat/utils/filterContext';
import { UserPrompt, BotFunction } from 'types';
import logger from 'app/api/chat/utils/logger';
import { addBotFunctions } from 'app/api/chat/controllers/BotHandlers';
import getMessageContent from 'app/api/chat/utils/messageUtils';

const config: AppConfig = getConfig();
const MAX_PROMPT_LENGTH = 128000;
const sessionTimeout = 60 * 60 * 1000; // 1 hour session timeout
const maxContextMessages = 100;

const clientContexts = new Map<string, UserPrompt[]>();

export async function POST(request: NextRequest) {
  const requestId = uuidv4();
  const clientId = request.headers.get('x-client-id') || `anon-${uuidv4()}`;

  logger.silly(`Received POST request [${requestId}] from clientId: ${clientId}`);

  const { limited, retryAfter } = checkRateLimit(clientId);
  if (limited) {
    logger.warn(`Rate limit exceeded for clientId: ${clientId}, RequestId: ${requestId}`);
    return NextResponse.json({ error: 'Too Many Requests' }, {
      status: 429,
      headers: { 'Retry-After': `${retryAfter}` },
    });
  }

  try {
    const body = await request.json();
    logger.debug(`Request body for RequestId: ${requestId}, clientId: ${clientId}: ${JSON.stringify(body)}`);

    const { messages } = body;
    if (!Array.isArray(messages)) {
      logger.warn(`Invalid format: messages must be an array. RequestId: ${requestId}`);
      return NextResponse.json({ error: 'Invalid format' }, { status: 400 });
    }

    const validMessages = extractValidMessages(messages);
    logger.silly(`Filtered ${validMessages.length} valid messages for clientId: ${clientId}`);

    if (validMessages.length === 0) {
      return NextResponse.json({ error: 'No valid messages provided' }, { status: 400 });
    }

    let context = clientContexts.get(clientId) || [];
    context = [...validMessages.reverse(), ...context].slice(-maxContextMessages);
    clientContexts.set(clientId, context);

    logger.silly(`Updated context size for clientId: ${clientId}: ${context.length}`);

    const botFunctions: BotFunction[] = [];
    addBotFunctions(botFunctions, config);

    const response = await processBotsSequentially(botFunctions, context);

    logger.silly(`Sequential response generated for clientId: ${clientId}, RequestId: ${requestId}`);
    return NextResponse.json(response, { status: 200 });

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred';
    logger.error(`Error handling POST request for clientId: ${clientId}, RequestId: ${requestId}: ${errorMessage}`);
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
  }
}

async function processBotsSequentially(
  botFunctions: BotFunction[],
  context: UserPrompt[]
): Promise<{ responses: { persona: string, message: string }[] }> {
  const responses: { persona: string, message: string }[] = [];

  // Rotate through the bots sequentially across multiple requests
  const nextBot = botFunctions.shift(); // Get the next bot in rotation
  botFunctions.push(nextBot!); // Place the bot back at the end for round-robin rotation

  try {
    const botResponse = await nextBot!.generate(context);
    if (botResponse) {
      const message = getMessageContent(botResponse);
      console.log('Generated message:', message); // Debugging log
      responses.push({ persona: nextBot!.persona, message });

      logger.silly(`Response generated by bot ${nextBot!.persona}.`);
      context.push({ role: 'bot', content: message, persona: nextBot!.persona });
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred';
    logger.error(`Error processing bot ${nextBot!.persona}: ${errorMessage}`);
    responses.push({ persona: nextBot!.persona, message: `Error: ${errorMessage}` });
  }

  return { responses };
}
